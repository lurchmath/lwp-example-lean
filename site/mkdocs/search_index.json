{
    "docs": [
        {
            "location": "/", 
            "text": "Lean Example App Tutorial\n\n\nThis tutorial comes in eight parts.  It assumes you know the basics of\nLean first; if not, try at least the first chapter or so of\n\nits tutorial\n.  Then continue here:\n\n\n\n\nPart 1: Marking Lean Code\n\n\nPart 2: Hiding Commands\n\n\nPart 3: Connecting Types to Terms\n\n\nPart 4: Definitions, Theorems, Proofs\n\n\nPart 5: Building Term Trees\n\n\nPart 6: Sections\n\n\nPart 7: Namespaces\n\n\nPart 8: Symbols\n\n\n\n\nOr you can\n\nreturn to the repository\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#lean-example-app-tutorial", 
            "text": "This tutorial comes in eight parts.  It assumes you know the basics of\nLean first; if not, try at least the first chapter or so of its tutorial .  Then continue here:   Part 1: Marking Lean Code  Part 2: Hiding Commands  Part 3: Connecting Types to Terms  Part 4: Definitions, Theorems, Proofs  Part 5: Building Term Trees  Part 6: Sections  Part 7: Namespaces  Part 8: Symbols   Or you can return to the repository .", 
            "title": "Lean Example App Tutorial"
        }, 
        {
            "location": "/tutorial-1/", 
            "text": "Lean App Tutorial, Part 1\n\n\nThis application uses the \nLurch Web Platform\n to provide a simple interface\nto the theorem prover \nLean\n (actually, its\n\nJavaScript implementation\n), which\nenables us to validate documents that express mathematics using dependent\ntype theory.\n\n\nWhat does it do?\n\n\nThis tutorial assumes that you're familiar with Lean.  If not, consider\nstarting with \nLean's own tutorial\n\nfirst.\n\n\nThe app documented here is a web-based word processor whose controls are\nself-explanatory, with some new features.\n\n\n\n\nTry the web app live now.\n\n\nMarking Lean code\n\n\nThe buttons on the toolbar above provide a way for users to mark sections of\ntheir document as Lean code and have those sections checked for validity.\n\n\nThe first of three buttons whose icon is two square brackets, \n[ ]\n, can be\nused to mark a section of text as Lean code.  This wraps the text in special\nsquare brackets as a visual indicator of the special treatment the app will\ngive that text.  When the user's cursor is inside such code, a bubble will\nbe drawn around the code to make that fact visually obvious.\n\n\n\n\nUsers who do not wish to see the brackets (and rely\ninstead only on the bubbles that appear when the cursor is inside the code)\ncan toggle that feature using the View menu.\n\n\n\n\nThe other two bracket buttons, as well as the arrow button, will be covered\nin later parts of this tutorial.\n\n\nChecking with Lean\n\n\nThe collection of Lean code in the document can be run through Lean in one\nstep using the \"Run Lean\" button in the toolbar.  This can take several\nseconds, since running a sophisticated application like Lean in a browser\nwindow is a nontrivial operation.  Thus it is only run when the user\nexplicitly clicks the button.\n\n\nAfter it has been run, bubbles that produced any kind of output are\ndecorated with a symbol, either \n or \n, indicating whether the message was an error.  You\ncan find details about the Lean output by hovering your mouse over the\nsymbol in question, as shown below.\n\n\n\n\nSo what?\n\n\nBenefits\n\n\nThis means there is a simple UI in which you can type\n\nliterate\n Lean code,\nand it looks nice.  Furthermore, the validation results are presented as\nnicely as they are in \nthe official online Lean\nenvironment\n.\n\n\nMissing pieces\n\n\nThere are many disadvantages to the simple app just demonstrated, many of\nwhich will be addressed individually in later pages in this tutorial.  The\nfirst disadvantage that comes to mind is that the reader still needs to\nspeak Lean code rather fluently (e.g., \ncheck\n and \nprint\n and other\ncommands) to use this software.  How might we improve that?  Let's see:\n\n\nContinue to Part 2.", 
            "title": "Part 1"
        }, 
        {
            "location": "/tutorial-1/#lean-app-tutorial-part-1", 
            "text": "This application uses the  Lurch Web Platform  to provide a simple interface\nto the theorem prover  Lean  (actually, its JavaScript implementation ), which\nenables us to validate documents that express mathematics using dependent\ntype theory.", 
            "title": "Lean App Tutorial, Part 1"
        }, 
        {
            "location": "/tutorial-1/#what-does-it-do", 
            "text": "This tutorial assumes that you're familiar with Lean.  If not, consider\nstarting with  Lean's own tutorial \nfirst.  The app documented here is a web-based word processor whose controls are\nself-explanatory, with some new features.   Try the web app live now.", 
            "title": "What does it do?"
        }, 
        {
            "location": "/tutorial-1/#marking-lean-code", 
            "text": "The buttons on the toolbar above provide a way for users to mark sections of\ntheir document as Lean code and have those sections checked for validity.  The first of three buttons whose icon is two square brackets,  [ ] , can be\nused to mark a section of text as Lean code.  This wraps the text in special\nsquare brackets as a visual indicator of the special treatment the app will\ngive that text.  When the user's cursor is inside such code, a bubble will\nbe drawn around the code to make that fact visually obvious.   Users who do not wish to see the brackets (and rely\ninstead only on the bubbles that appear when the cursor is inside the code)\ncan toggle that feature using the View menu.   The other two bracket buttons, as well as the arrow button, will be covered\nin later parts of this tutorial.", 
            "title": "Marking Lean code"
        }, 
        {
            "location": "/tutorial-1/#checking-with-lean", 
            "text": "The collection of Lean code in the document can be run through Lean in one\nstep using the \"Run Lean\" button in the toolbar.  This can take several\nseconds, since running a sophisticated application like Lean in a browser\nwindow is a nontrivial operation.  Thus it is only run when the user\nexplicitly clicks the button.  After it has been run, bubbles that produced any kind of output are\ndecorated with a symbol, either   or  , indicating whether the message was an error.  You\ncan find details about the Lean output by hovering your mouse over the\nsymbol in question, as shown below.", 
            "title": "Checking with Lean"
        }, 
        {
            "location": "/tutorial-1/#so-what", 
            "text": "", 
            "title": "So what?"
        }, 
        {
            "location": "/tutorial-1/#benefits", 
            "text": "This means there is a simple UI in which you can type literate  Lean code,\nand it looks nice.  Furthermore, the validation results are presented as\nnicely as they are in  the official online Lean\nenvironment .", 
            "title": "Benefits"
        }, 
        {
            "location": "/tutorial-1/#missing-pieces", 
            "text": "There are many disadvantages to the simple app just demonstrated, many of\nwhich will be addressed individually in later pages in this tutorial.  The\nfirst disadvantage that comes to mind is that the reader still needs to\nspeak Lean code rather fluently (e.g.,  check  and  print  and other\ncommands) to use this software.  How might we improve that?  Let's see:  Continue to Part 2.", 
            "title": "Missing pieces"
        }, 
        {
            "location": "/tutorial-2/", 
            "text": "Lean App Tutorial, Part 2\n\n\nThis page assumes you've read \nPart 1\n.\n\n\nTry the web app live now.\n\n\nThe end of that document pointed out a needed improvement:  The bubbles in a\ndocument all contain Lean code, which expects the reader to be fluent in it.\nLet's see a first step towards reducing that problem.\n\n\nHiding Commands\n\n\nIn the previous part of the tutorial, we saw that entire Lean commands can\nbe embedded in a bubble, like so:\n\n\n\n\nIf you wish to hide the command, leaving only the mathematical content (in\nthis case an expression in the language of dependent type theory),\nright-click the bubble and choose the \"Edit command...\" item from the\ncontext menu.  Specify the command there, and you may then remove it from\nthe bubble.  It will appear on the bubble's tag, and function as if it were\ninside the bubble, at the beginning, as shown here.\n\n\n\n\nSo what?\n\n\nBenefits\n\n\nNow Lean code can be more naturally worked into the surrounding prose, as\nshown in the example below.\n\n\n\n\n(The square brackets have been hidden in this example, using the View menu.)\n\n\nMissing pieces\n\n\nMany additional aspects of Lean syntax must still be placed inside term\nbubbles, most notably the \na : A\n notation at the heart of dependent type\ntheory.  Let's address that now:\n\n\nContinue to Part 3.", 
            "title": "Part 2"
        }, 
        {
            "location": "/tutorial-2/#lean-app-tutorial-part-2", 
            "text": "This page assumes you've read  Part 1 .  Try the web app live now.  The end of that document pointed out a needed improvement:  The bubbles in a\ndocument all contain Lean code, which expects the reader to be fluent in it.\nLet's see a first step towards reducing that problem.", 
            "title": "Lean App Tutorial, Part 2"
        }, 
        {
            "location": "/tutorial-2/#hiding-commands", 
            "text": "In the previous part of the tutorial, we saw that entire Lean commands can\nbe embedded in a bubble, like so:   If you wish to hide the command, leaving only the mathematical content (in\nthis case an expression in the language of dependent type theory),\nright-click the bubble and choose the \"Edit command...\" item from the\ncontext menu.  Specify the command there, and you may then remove it from\nthe bubble.  It will appear on the bubble's tag, and function as if it were\ninside the bubble, at the beginning, as shown here.", 
            "title": "Hiding Commands"
        }, 
        {
            "location": "/tutorial-2/#so-what", 
            "text": "", 
            "title": "So what?"
        }, 
        {
            "location": "/tutorial-2/#benefits", 
            "text": "Now Lean code can be more naturally worked into the surrounding prose, as\nshown in the example below.   (The square brackets have been hidden in this example, using the View menu.)", 
            "title": "Benefits"
        }, 
        {
            "location": "/tutorial-2/#missing-pieces", 
            "text": "Many additional aspects of Lean syntax must still be placed inside term\nbubbles, most notably the  a : A  notation at the heart of dependent type\ntheory.  Let's address that now:  Continue to Part 3.", 
            "title": "Missing pieces"
        }, 
        {
            "location": "/tutorial-3/", 
            "text": "Lean App Tutorial, Part 3\n\n\nThis page assumes you've read Parts \n1\n and\n\n2\n.\n\n\nTry the web app live now.\n\n\nPart 2\n ended by pointing out that the UI could be better\nif the common syntactic form \na : A\n in Lean were supported in this app.\nThis page of the tutorial introduces how it's supported.\n\n\nType Groups\n\n\nNext to the toolbar button that wraps text in a \"term\" bubble is a button\nfor wrapping text in a \"type\" bubble.  While term bubbles are gray, type\nbubbles are green.  The toolbar button for marking text as a type is\nimmediately to the right of that for marking text as a term.\n\n\n\n\nIf you mark something as a type in your document, however, and click \"Run\nLean,\" it will say that the type is not attached to any term, and thus\ncannot be validated on its own.  (The gold starburst indicates a warning,\nas opposed to an outright error.)\n\n\n\n\nConnecting Types to Terms\n\n\nTo connect one bubble to another (such as a type to the term it modifies),\nuse the connection button in the toolbar, labeled \"Connect pieces of Lean\ncode\" in the image below.\n\n\n\n\nFollow this process:\n\n\n\n\nPlace your cursor inside the type bubble.\n\n\nClick the arrow button shown in the image above.\n\n\nClick inside the term that it modifies.\n\n\n\n\nThis connects the type to the term visually on screen, with an arrow.  It\nalso permits you to separate the type and the term in your text, and let the\ntext flow as smoothly as you'd like around them.  The type can precede the\nterm, or follow it.  Here is an example.\n\n\n\n\nTo disconnect a type and a term, just perform the connection process again.\nIt toggles the connection off.\n\n\nValidation\n\n\nWhen you \"Run Lean\" on a document with the configuration shown above, the\ntype is treated as modifying the term.  If the term has a \"check\" command\nembedded in it, for instance, the check will include the type assertion, as\nshown here.\n\n\n\n\nSo what?\n\n\nBenefits\n\n\nThe idea introduced above makes further progress in permitting you as a\ndocument author to structure your text as you see fit, without needing to\nbe bound by the notational conventions of Lean.  The example images above\nshow how you can structure your prose as you like, and fit bubbles and\nconnections among them into your prose in whatever way it necessitates.\n\n\nNote that the visual clutter shown above completely disappears when the user\ntakes their cursor out of the bubbles in question.  The image below shows\nthe document with validation complete (so the green checks are present) but\nwith bubble boundaries hidden (from the View menu).\n\n\n\n\nMissing pieces\n\n\nOf course, there are still occasions where some Lean syntax is unavoidable.\nFor instance, in the code \ndefinition A : B := C\n, we have no way to\nseparate the \nC\n (which may be a very large expression) from the rest.\nWe'll see how to solve that problem next.\n\n\nContinue to Part 4.", 
            "title": "Part 3"
        }, 
        {
            "location": "/tutorial-3/#lean-app-tutorial-part-3", 
            "text": "This page assumes you've read Parts  1  and 2 .  Try the web app live now.  Part 2  ended by pointing out that the UI could be better\nif the common syntactic form  a : A  in Lean were supported in this app.\nThis page of the tutorial introduces how it's supported.", 
            "title": "Lean App Tutorial, Part 3"
        }, 
        {
            "location": "/tutorial-3/#type-groups", 
            "text": "Next to the toolbar button that wraps text in a \"term\" bubble is a button\nfor wrapping text in a \"type\" bubble.  While term bubbles are gray, type\nbubbles are green.  The toolbar button for marking text as a type is\nimmediately to the right of that for marking text as a term.   If you mark something as a type in your document, however, and click \"Run\nLean,\" it will say that the type is not attached to any term, and thus\ncannot be validated on its own.  (The gold starburst indicates a warning,\nas opposed to an outright error.)", 
            "title": "Type Groups"
        }, 
        {
            "location": "/tutorial-3/#connecting-types-to-terms", 
            "text": "To connect one bubble to another (such as a type to the term it modifies),\nuse the connection button in the toolbar, labeled \"Connect pieces of Lean\ncode\" in the image below.   Follow this process:   Place your cursor inside the type bubble.  Click the arrow button shown in the image above.  Click inside the term that it modifies.   This connects the type to the term visually on screen, with an arrow.  It\nalso permits you to separate the type and the term in your text, and let the\ntext flow as smoothly as you'd like around them.  The type can precede the\nterm, or follow it.  Here is an example.   To disconnect a type and a term, just perform the connection process again.\nIt toggles the connection off.", 
            "title": "Connecting Types to Terms"
        }, 
        {
            "location": "/tutorial-3/#validation", 
            "text": "When you \"Run Lean\" on a document with the configuration shown above, the\ntype is treated as modifying the term.  If the term has a \"check\" command\nembedded in it, for instance, the check will include the type assertion, as\nshown here.", 
            "title": "Validation"
        }, 
        {
            "location": "/tutorial-3/#so-what", 
            "text": "", 
            "title": "So what?"
        }, 
        {
            "location": "/tutorial-3/#benefits", 
            "text": "The idea introduced above makes further progress in permitting you as a\ndocument author to structure your text as you see fit, without needing to\nbe bound by the notational conventions of Lean.  The example images above\nshow how you can structure your prose as you like, and fit bubbles and\nconnections among them into your prose in whatever way it necessitates.  Note that the visual clutter shown above completely disappears when the user\ntakes their cursor out of the bubbles in question.  The image below shows\nthe document with validation complete (so the green checks are present) but\nwith bubble boundaries hidden (from the View menu).", 
            "title": "Benefits"
        }, 
        {
            "location": "/tutorial-3/#missing-pieces", 
            "text": "Of course, there are still occasions where some Lean syntax is unavoidable.\nFor instance, in the code  definition A : B := C , we have no way to\nseparate the  C  (which may be a very large expression) from the rest.\nWe'll see how to solve that problem next.  Continue to Part 4.", 
            "title": "Missing pieces"
        }, 
        {
            "location": "/tutorial-4/", 
            "text": "Lean App Tutorial, Part 4\n\n\nThis page assumes you've read Parts \n1\n, \n2\n,\nand \n3\n.\n\n\nTry the web app live now.\n\n\nThe end of \nPart 3\n pointed out that Lean definitions (and\nhence theorems and examples) cannot yet have their body split out from the\nrest of the code.  This tutorial page solves that problem.\n\n\nBody Groups\n\n\nIn Lean, theorems, defintions, and examples are all of the form\n\ndefinition name : type := body\n, where the word \"definition\" may instead be\n\"theorem\" or \"example.\"  This is the next syntax we permit breaking out.  We\ncall the final element of that structure the \"body\" and have a new bubble\ntype for it in the app.\n\n\nExample 1: A Definition\n\n\nLet's assume that we want to write a document embodying the Lean code\n\ndefinition three : nat := 3\n.  Certainly, we could simply put that code\ninside a term bubble, but that requires our document to contain Lean\nsyntax.  Here is an alternate way.\n\n\n\n\nThis document has plenty of non-bubbled text that is irrelevant to the\nresults of the \"Run Lean\" operation, which pays attention only to the\ncontents of the bubbles.  But that non-bubbled text is very helpful, for\nsomewhat obvious reasons (also described \nat the end of this\npage\n).\n\n\nIf we use the View menu to show the boundaries of the bubbles then the\nresult looks like the following.\n\n\n\n\nNotice that the app can convert these broken-apart pieces into Lean code\ncorrectly, so that it validates.\n\n\nThe type is connected to the term in the manner introduced in \nthe previous\npart of this tutorial\n.  But the body is also connected in\nthe same way, as shown here.\n\n\n\n\nCreating the Structure\n\n\nTo create a body group, use the blue bracket button in the toolbar below\n(third button of those labeled \"Mark Lean code in your document\").\n\n\n\n\nTo connect a body to the term being defined (or the statement of a theorem,\nusing the body as its proof), use the same technique as discussed in \nthe\nprevious part of this tutorial\n:\n\n\n\n\nPlace your cursor inside the body bubble.\n\n\nClick the arrow button in the toolbar.\n\n\nClick inside the term for which that body is the definition or proof.\n\n\n\n\nWhat goes inside\n\n\nA body bubble's contents, if they are just plain text, are interpreted like\nthe contents of a term bubble.  This is how the example above works.  But\nthat is just the simplest of the ways you can use a body bubble.  Here is a\ncomprehensive list.\n\n\n\n\nIf a body bubble contains no other bubbles, then its text content is\n   interpreted as the Lean code for a term (as above).\n\n\nIf a body bubble contains a single term bubble, then the body bubble's\n   meaning is the same as that of the single term bubble.\n\n\nIf a body bubble contains n term bubbles, then the first n-1 are seen as\n   parameters and the final one is seen as the body of a lambda expression.\n   Thus for example, the structure shown below defines a function.  It could\n   be used as the body of a definition.\n\n\n\n\n\n\nThe second case is a generalization of the first, permitting explanatory\ntext outside the inner bubble; the first case can be seen as shorthand for\nthe second.  The third case is more general still, because the second case\nis the 0-parameter version of the third case.\n\n\nExample 2: Theorem and Proof\n\n\nThis permits us to put a little exposition in our theorems and proofs, as\nshown in the following image.\n\n\n\n\nThe structure that reveals itself when your cursor is inside the main term\n(the name and premises of the theorem) is as shown below.\n\n\n\n\nIn these examples, I've placed a term bubble inside the body bubble, which\nshows that the meaning is the same.\n\n\nSo what?\n\n\nBenefits\n\n\nThis lets us make more readable definitions and theorems, as shown above.\nThe expository text between bubbles has two main benefits.  A human reader\ncan understand the document without thinking through Lean syntax.  And the\ndocument author, when that writer is a student, can practice expressing\nmathematical proofs in a readable and understandable way, and have that\nexposition evaluated by an instructor.\n\n\nMissing pieces\n\n\nThe definition and proof shown above are both very short.  If they were\nlonger, there would be very large, indivisible term bubbles in the document,\nwhich cannot contain prose comments.  Let's see how to fix that.\n\n\nContinue to Part 5.", 
            "title": "Part 4"
        }, 
        {
            "location": "/tutorial-4/#lean-app-tutorial-part-4", 
            "text": "This page assumes you've read Parts  1 ,  2 ,\nand  3 .  Try the web app live now.  The end of  Part 3  pointed out that Lean definitions (and\nhence theorems and examples) cannot yet have their body split out from the\nrest of the code.  This tutorial page solves that problem.", 
            "title": "Lean App Tutorial, Part 4"
        }, 
        {
            "location": "/tutorial-4/#body-groups", 
            "text": "In Lean, theorems, defintions, and examples are all of the form definition name : type := body , where the word \"definition\" may instead be\n\"theorem\" or \"example.\"  This is the next syntax we permit breaking out.  We\ncall the final element of that structure the \"body\" and have a new bubble\ntype for it in the app.", 
            "title": "Body Groups"
        }, 
        {
            "location": "/tutorial-4/#example-1-a-definition", 
            "text": "Let's assume that we want to write a document embodying the Lean code definition three : nat := 3 .  Certainly, we could simply put that code\ninside a term bubble, but that requires our document to contain Lean\nsyntax.  Here is an alternate way.   This document has plenty of non-bubbled text that is irrelevant to the\nresults of the \"Run Lean\" operation, which pays attention only to the\ncontents of the bubbles.  But that non-bubbled text is very helpful, for\nsomewhat obvious reasons (also described  at the end of this\npage ).  If we use the View menu to show the boundaries of the bubbles then the\nresult looks like the following.   Notice that the app can convert these broken-apart pieces into Lean code\ncorrectly, so that it validates.  The type is connected to the term in the manner introduced in  the previous\npart of this tutorial .  But the body is also connected in\nthe same way, as shown here.", 
            "title": "Example 1: A Definition"
        }, 
        {
            "location": "/tutorial-4/#creating-the-structure", 
            "text": "To create a body group, use the blue bracket button in the toolbar below\n(third button of those labeled \"Mark Lean code in your document\").   To connect a body to the term being defined (or the statement of a theorem,\nusing the body as its proof), use the same technique as discussed in  the\nprevious part of this tutorial :   Place your cursor inside the body bubble.  Click the arrow button in the toolbar.  Click inside the term for which that body is the definition or proof.", 
            "title": "Creating the Structure"
        }, 
        {
            "location": "/tutorial-4/#what-goes-inside", 
            "text": "A body bubble's contents, if they are just plain text, are interpreted like\nthe contents of a term bubble.  This is how the example above works.  But\nthat is just the simplest of the ways you can use a body bubble.  Here is a\ncomprehensive list.   If a body bubble contains no other bubbles, then its text content is\n   interpreted as the Lean code for a term (as above).  If a body bubble contains a single term bubble, then the body bubble's\n   meaning is the same as that of the single term bubble.  If a body bubble contains n term bubbles, then the first n-1 are seen as\n   parameters and the final one is seen as the body of a lambda expression.\n   Thus for example, the structure shown below defines a function.  It could\n   be used as the body of a definition.    The second case is a generalization of the first, permitting explanatory\ntext outside the inner bubble; the first case can be seen as shorthand for\nthe second.  The third case is more general still, because the second case\nis the 0-parameter version of the third case.", 
            "title": "What goes inside"
        }, 
        {
            "location": "/tutorial-4/#example-2-theorem-and-proof", 
            "text": "This permits us to put a little exposition in our theorems and proofs, as\nshown in the following image.   The structure that reveals itself when your cursor is inside the main term\n(the name and premises of the theorem) is as shown below.   In these examples, I've placed a term bubble inside the body bubble, which\nshows that the meaning is the same.", 
            "title": "Example 2: Theorem and Proof"
        }, 
        {
            "location": "/tutorial-4/#so-what", 
            "text": "", 
            "title": "So what?"
        }, 
        {
            "location": "/tutorial-4/#benefits", 
            "text": "This lets us make more readable definitions and theorems, as shown above.\nThe expository text between bubbles has two main benefits.  A human reader\ncan understand the document without thinking through Lean syntax.  And the\ndocument author, when that writer is a student, can practice expressing\nmathematical proofs in a readable and understandable way, and have that\nexposition evaluated by an instructor.", 
            "title": "Benefits"
        }, 
        {
            "location": "/tutorial-4/#missing-pieces", 
            "text": "The definition and proof shown above are both very short.  If they were\nlonger, there would be very large, indivisible term bubbles in the document,\nwhich cannot contain prose comments.  Let's see how to fix that.  Continue to Part 5.", 
            "title": "Missing pieces"
        }, 
        {
            "location": "/tutorial-5/", 
            "text": "Lean App Tutorial, Part 5\n\n\nThis page assumes you've read Parts \n1\n, \n2\n,\n\n3\n, and \n4\n.\n\n\nTry the web app live now.\n\n\nThe end of \nPart 4\n pointed out that while the bodies of Lean\ndefinitions, theorems, and examples can be split out from the name and type\nof the definition, etc., they remain indivisible, which presents a challenge\nto inserting helpful exposition among them.\n\n\nTerm Trees\n\n\nConsider a Lean term like \nand.intro (and.elim_right E) (and.elim_left E)\n,\nwhich would appear in the proof of the commutativity of the conjunction\noperator.  This term is nested applications, a syntax tree.  We could\ndiagram its hierarchical structure as follows.\n\n\nand.intro\n    and.elim_right\n        E\n    and.elim_left\n        E\n\n\n\nIn a document, it is inconvenient to have to place all these symbols one\nafter another, because they prevent our inserting exposition between them.\nThis is especially true since this is only a small example, and much larger\nproofs are common.\n\n\nWe would like to do something more like the following.\n\n\n\n\nThis is possible by breaking the syntax tree for the proof term into\nsmaller pieces, which we then connect with arrows, so that the app knows\nhow to reconstruct the original Lean code from the pieces.\n\n\nBuilding Term Trees\n\n\nIf you have a term of the form \noperator operand1 ... operandN\n in a\ndocument, and you wish to break it up, do so as follows.\n\n\n\n\nBreak the term bubble surrounding the term.  (Do so by using the delete\n    or backspace key on either of its boundaries.)\n\n\nPlace a new term bubble around just the operator.\n\n\nPlace a new term bubble around the first operand.\n\n\nUse the arrow button on the toolbar to connect the operator to that\n    operand.\n\n\nRepeat the last two steps for the second operand, and the third, and so\n    on.\n\n\n\n\nThe app will understand that the source of the arrows is the operator, and\nthe destinations are the operands.  The order of the arrows is significant,\nand is displayed by the order in which the arrows leave the operator bubble.\nTo destroy arrows and reform them, simply repeat the connecting process, and\nthe arrow will be toggled off; this can help you reorder them.\n\n\nNote that the operator and operands do not need to appear in the document in\nthe order in which they would appear in Lean code.  As long as the arrows\nexist in the correct direction and the correct order, the bubbles themselves\ncan appear in any sequence.\n\n\nExample\n\n\nConsider the image shown earlier on this page.  Here is how it was created.\nBubbles were placed as follows:\n\n\n\n\nConnections were made from the theorem statement and body to the theorem\nname in the way you already know from \nthe previous tutorial page\n:\n\n\n\n\nInside a body, the first terms are treated as parameters, which in the case\nof proofs means that they function as assumptions.  In this proof, we have\none assumption, which should be assigned a type as shown here.\n\n\n\n\nEach of the elimination steps in the body is applied to its argument, and in\nturn, has the introduction step applied to it.  Thus the remainder of the\ntheorem body is actually just one large term, split out into five bubbles,\nforming one term tree.  In the following image, the cursor is in the shaded\nbubble, so you can see only the arrows into and out of that bubble.  There\nare corresponding arrows into and out of the \nand.elim_left\n step as well.\n\n\n\n\nThus the set of arrows connecting the last five term bubbles in the proof\nform the same tree shown at the top of this page, with the arrows pointing\nfrom each term to its subterm(s).\n\n\nSo what?\n\n\nBenefits\n\n\nAs you can see from the example in this document, we can now begin to write\ntheorems in a much more natural style, with as much exposition between\nsteps as we find necessary.\n\n\nIn fact, the example shows that we can even reorder the elements of the\nproof term to be in whatever sequence we feel natural; the introduction\nstep, which would appear first in the Lean code\n\nand.intro (and.elim_right E) (and.elim_left E)\n, appears last in the\ndocument.\n\n\nMissing pieces\n\n\nThe statement of the theorem still contains the ugly code bit\n\n{P Q : Prop}\n, which we have not yet learned to eliminate.  Let's do that\nnext.\n\n\nContinue to Part 6.", 
            "title": "Part 5"
        }, 
        {
            "location": "/tutorial-5/#lean-app-tutorial-part-5", 
            "text": "This page assumes you've read Parts  1 ,  2 , 3 , and  4 .  Try the web app live now.  The end of  Part 4  pointed out that while the bodies of Lean\ndefinitions, theorems, and examples can be split out from the name and type\nof the definition, etc., they remain indivisible, which presents a challenge\nto inserting helpful exposition among them.", 
            "title": "Lean App Tutorial, Part 5"
        }, 
        {
            "location": "/tutorial-5/#term-trees", 
            "text": "Consider a Lean term like  and.intro (and.elim_right E) (and.elim_left E) ,\nwhich would appear in the proof of the commutativity of the conjunction\noperator.  This term is nested applications, a syntax tree.  We could\ndiagram its hierarchical structure as follows.  and.intro\n    and.elim_right\n        E\n    and.elim_left\n        E  In a document, it is inconvenient to have to place all these symbols one\nafter another, because they prevent our inserting exposition between them.\nThis is especially true since this is only a small example, and much larger\nproofs are common.  We would like to do something more like the following.   This is possible by breaking the syntax tree for the proof term into\nsmaller pieces, which we then connect with arrows, so that the app knows\nhow to reconstruct the original Lean code from the pieces.", 
            "title": "Term Trees"
        }, 
        {
            "location": "/tutorial-5/#building-term-trees", 
            "text": "If you have a term of the form  operator operand1 ... operandN  in a\ndocument, and you wish to break it up, do so as follows.   Break the term bubble surrounding the term.  (Do so by using the delete\n    or backspace key on either of its boundaries.)  Place a new term bubble around just the operator.  Place a new term bubble around the first operand.  Use the arrow button on the toolbar to connect the operator to that\n    operand.  Repeat the last two steps for the second operand, and the third, and so\n    on.   The app will understand that the source of the arrows is the operator, and\nthe destinations are the operands.  The order of the arrows is significant,\nand is displayed by the order in which the arrows leave the operator bubble.\nTo destroy arrows and reform them, simply repeat the connecting process, and\nthe arrow will be toggled off; this can help you reorder them.  Note that the operator and operands do not need to appear in the document in\nthe order in which they would appear in Lean code.  As long as the arrows\nexist in the correct direction and the correct order, the bubbles themselves\ncan appear in any sequence.", 
            "title": "Building Term Trees"
        }, 
        {
            "location": "/tutorial-5/#example", 
            "text": "Consider the image shown earlier on this page.  Here is how it was created.\nBubbles were placed as follows:   Connections were made from the theorem statement and body to the theorem\nname in the way you already know from  the previous tutorial page :   Inside a body, the first terms are treated as parameters, which in the case\nof proofs means that they function as assumptions.  In this proof, we have\none assumption, which should be assigned a type as shown here.   Each of the elimination steps in the body is applied to its argument, and in\nturn, has the introduction step applied to it.  Thus the remainder of the\ntheorem body is actually just one large term, split out into five bubbles,\nforming one term tree.  In the following image, the cursor is in the shaded\nbubble, so you can see only the arrows into and out of that bubble.  There\nare corresponding arrows into and out of the  and.elim_left  step as well.   Thus the set of arrows connecting the last five term bubbles in the proof\nform the same tree shown at the top of this page, with the arrows pointing\nfrom each term to its subterm(s).", 
            "title": "Example"
        }, 
        {
            "location": "/tutorial-5/#so-what", 
            "text": "", 
            "title": "So what?"
        }, 
        {
            "location": "/tutorial-5/#benefits", 
            "text": "As you can see from the example in this document, we can now begin to write\ntheorems in a much more natural style, with as much exposition between\nsteps as we find necessary.  In fact, the example shows that we can even reorder the elements of the\nproof term to be in whatever sequence we feel natural; the introduction\nstep, which would appear first in the Lean code and.intro (and.elim_right E) (and.elim_left E) , appears last in the\ndocument.", 
            "title": "Benefits"
        }, 
        {
            "location": "/tutorial-5/#missing-pieces", 
            "text": "The statement of the theorem still contains the ugly code bit {P Q : Prop} , which we have not yet learned to eliminate.  Let's do that\nnext.  Continue to Part 6.", 
            "title": "Missing pieces"
        }, 
        {
            "location": "/tutorial-6/", 
            "text": "Lean App Tutorial, Part 6\n\n\nThis page assumes you've read Parts \n1\n, \n2\n,\n\n3\n, \n4\n, and \n5\n.\n\n\nTry the web app live now.\n\n\nThe end of \nPart 5\n promised to take code like \n{P Q : Prop}\n\nout of the names of theorems, and this tutorial page shows how.\n\n\nSections\n\n\nRecall the nicely organized theorem from \nthe previous tutorial\npage\n.\n\n\n\n\nThe one complaint we had about it was that its statement had to contain the\ndeclarations of the variables \nP\n and \nQ\n, using the Lean syntax\n\nsimple {P Q : Prop}\n.  To make our documents more readable, we would like\nsomething more like the following.\n\n\n\n\nThis can be accomplished very simply, as follows.\n\n\n\n\nCreate a term bubble for each variable, before the theorem.\n\n\nEmbed in each such term bubble the Lean command \"variable\"\n    (as in \nPart 2 of the tutorial\n).\n\n\nAssign a type to each such bubble (or the same type to more than one)\n    (as in \nPart 3 of the tutorial\n).\n\n\nWrap the variable terms and the theorem in one, large body bubble.\n    Do not connect it to anything via arrows.\n\n\n\n\nSuch disconnected body bubbles function as \"sections\" in Lean code, and will\nthus localize the variable declarations to the theorem only (unless you\nplace other theorems inside the same body, of course).\n\n\nThe bubble structure described above is shown here.\n\n\n\n\nSo what?\n\n\nBenefits\n\n\nWe have further cleaned up the syntax for stating and proving theorems.\nThere is now almost no Lean syntax in the theorem at all!\n\n\nMissing pieces\n\n\nIf we can create Lean \nsection\ns, why not Lean \nnamespace\ns?  We can!\n\n\nContinue to Part 7.", 
            "title": "Part 6"
        }, 
        {
            "location": "/tutorial-6/#lean-app-tutorial-part-6", 
            "text": "This page assumes you've read Parts  1 ,  2 , 3 ,  4 , and  5 .  Try the web app live now.  The end of  Part 5  promised to take code like  {P Q : Prop} \nout of the names of theorems, and this tutorial page shows how.", 
            "title": "Lean App Tutorial, Part 6"
        }, 
        {
            "location": "/tutorial-6/#sections", 
            "text": "Recall the nicely organized theorem from  the previous tutorial\npage .   The one complaint we had about it was that its statement had to contain the\ndeclarations of the variables  P  and  Q , using the Lean syntax simple {P Q : Prop} .  To make our documents more readable, we would like\nsomething more like the following.   This can be accomplished very simply, as follows.   Create a term bubble for each variable, before the theorem.  Embed in each such term bubble the Lean command \"variable\"\n    (as in  Part 2 of the tutorial ).  Assign a type to each such bubble (or the same type to more than one)\n    (as in  Part 3 of the tutorial ).  Wrap the variable terms and the theorem in one, large body bubble.\n    Do not connect it to anything via arrows.   Such disconnected body bubbles function as \"sections\" in Lean code, and will\nthus localize the variable declarations to the theorem only (unless you\nplace other theorems inside the same body, of course).  The bubble structure described above is shown here.", 
            "title": "Sections"
        }, 
        {
            "location": "/tutorial-6/#so-what", 
            "text": "", 
            "title": "So what?"
        }, 
        {
            "location": "/tutorial-6/#benefits", 
            "text": "We have further cleaned up the syntax for stating and proving theorems.\nThere is now almost no Lean syntax in the theorem at all!", 
            "title": "Benefits"
        }, 
        {
            "location": "/tutorial-6/#missing-pieces", 
            "text": "If we can create Lean  section s, why not Lean  namespace s?  We can!  Continue to Part 7.", 
            "title": "Missing pieces"
        }, 
        {
            "location": "/tutorial-7/", 
            "text": "Lean App Tutorial, Part 7\n\n\nThis page assumes you've read Parts \n1\n, \n2\n,\n\n3\n, \n4\n, \n5\n, and\n\n6\n.\n\n\nTry the web app live now.\n\n\nThe end of \nPart 6\n stated that you can use Lean namespaces\njust as easily as Lean sections.  This tutorial page covers how to do so.\n\n\nNamespaces\n\n\nRecall the nicely organized theorem from \nthe previous tutorial\npage\n.\n\n\n\n\nWe could do the same thing in a namespace rather than a section, if we\nwanted to.  (We might want to in order to avoid filling the global\nnamespace with too many identifiers, or to organize our code, or to prevent\na clash with an existing theorem name, etc.)\n\n\nIt is a simple matter to change a section into a namespace, or vice versa.\n\n\n\n\nRight-click any text inside the Section bubble (but not inside any inner\n    bubble).\n\n\nFrom the context menu, choose \"Make this a namespace...\"\n\n\nEnter a valid Lean identifier in the box that appears.\n\n\nClick OK and the section will become a namespace.\n\n\n\n\nTo rename the namespace, or convert it back to a section, follow the same\nprocedure as above, but choosing the appropriate item from the context menu.\nThey are named in the obvious way.\n\n\nIf the bubble shown above were a namespace, we could then access its\ncontents outside the namespace using dot notation, as in any Lean code.\nSee the following example.\n\n\n\n\nSo what?\n\n\nBenefits\n\n\nYou can now organize your Lean code into namespaces in this app, just as you\ncould in Lean.  This is useful for the reasons stated above.\n\n\nMissing pieces\n\n\nThe final missing piece is that this app does not seem to use any of the\nattractive symbols Lean uses, such as the blackboard bold N for natural\nnumbers, and so on.\n\n\nLet's see how to fix that in the final part of the tutorial.\n\n\nContinue to Part 8.", 
            "title": "Part 7"
        }, 
        {
            "location": "/tutorial-7/#lean-app-tutorial-part-7", 
            "text": "This page assumes you've read Parts  1 ,  2 , 3 ,  4 ,  5 , and 6 .  Try the web app live now.  The end of  Part 6  stated that you can use Lean namespaces\njust as easily as Lean sections.  This tutorial page covers how to do so.", 
            "title": "Lean App Tutorial, Part 7"
        }, 
        {
            "location": "/tutorial-7/#namespaces", 
            "text": "Recall the nicely organized theorem from  the previous tutorial\npage .   We could do the same thing in a namespace rather than a section, if we\nwanted to.  (We might want to in order to avoid filling the global\nnamespace with too many identifiers, or to organize our code, or to prevent\na clash with an existing theorem name, etc.)  It is a simple matter to change a section into a namespace, or vice versa.   Right-click any text inside the Section bubble (but not inside any inner\n    bubble).  From the context menu, choose \"Make this a namespace...\"  Enter a valid Lean identifier in the box that appears.  Click OK and the section will become a namespace.   To rename the namespace, or convert it back to a section, follow the same\nprocedure as above, but choosing the appropriate item from the context menu.\nThey are named in the obvious way.  If the bubble shown above were a namespace, we could then access its\ncontents outside the namespace using dot notation, as in any Lean code.\nSee the following example.", 
            "title": "Namespaces"
        }, 
        {
            "location": "/tutorial-7/#so-what", 
            "text": "", 
            "title": "So what?"
        }, 
        {
            "location": "/tutorial-7/#benefits", 
            "text": "You can now organize your Lean code into namespaces in this app, just as you\ncould in Lean.  This is useful for the reasons stated above.", 
            "title": "Benefits"
        }, 
        {
            "location": "/tutorial-7/#missing-pieces", 
            "text": "The final missing piece is that this app does not seem to use any of the\nattractive symbols Lean uses, such as the blackboard bold N for natural\nnumbers, and so on.  Let's see how to fix that in the final part of the tutorial.  Continue to Part 8.", 
            "title": "Missing pieces"
        }, 
        {
            "location": "/tutorial-8/", 
            "text": "Lean App Tutorial, Part 8\n\n\nThis page assumes you've read Parts \n1\n, \n2\n,\n\n3\n, \n4\n, \n5\n,\n\n6\n, and \n7\n.\n\n\nTry the web app live now.\n\n\nThe end of \nPart 7\n promised a tutorial on inserting special\nsymbols into the document, which Lean understands.\n\n\nSymbols\n\n\nLean code can contain many Unicode characters that resemble mathematical\nnotation, and thus make documents more attractive.  This appliction supports\nthose characters, as shown in the image below.\n\n\n\n\nThe blackboard bold N stands for the natural numbers (formerly written nat)\nand the greek letter lambda stands for \"fun\" or \"assume\" in Lean.\n\n\nYou can enter these symbols by typing a backslash, followed by the symbol's\nname, followed by the spacebar (or alternately followed by another\nbackslash, if you're starting another symbol immediately afterwards).  For\nexample, to type the first line of the document shown above, you would\nproceed as follows.\n\n\n\n\nClick the button to start a term group.\n\n\nType \ncheck (3:\\nat\n.\n\n\nPress the spacebar, and \n\\nat\n will be replaced by the blackboard bold\n    N.\n\n\nType \n)\n.\n\n\n\n\nCatalog\n\n\nWhat symbols are available?  Lots!  Nearly 2,000, in fact!  But most of them\nare not useful in Lean itself.  Here are three ways to get started with\nkeyboard shortcuts:\n\n\n\n\nThe most important ones to know are \n\\and\n, \n\\or\n, \n\\to\n, \n\\neg\n,\n    \n\\forall\n, \n\\exists\n, \n\\pi\n, \n\\sigma\n, \n\\lambda\n, \n\\int\n, and \n\\nat\n.\n\n\nTake \nthe Lean tutorial\n, which\n    covers the keyboard shortcuts that work in Lean.  I imported the same\n    data file into this web app that they use in Lean, so all shortcuts that\n    work in Lean work here.\n\n\nIf you really want to know the full list of 1,959 shortcuts, you can\n    inspect \nthe (minified JSON) data file\n just mentioned.\n\n\n\n\nSo what?\n\n\nBenefits\n\n\nYour Lean documents will now look much less computer-ish, and much more\nmathematical and readable.\n\n\nMissing pieces\n\n\nThis is the last page of the tutorial, but surely you can think of ways that\nthis app could be improved.  Feel free to \nclone the project and start\ndeveloping with us!\n  Or contact one of the members\nof the development team through\n\nGitHub\n.\nYou can also open an issue there for bug reports or feature requests.", 
            "title": "Part 8"
        }, 
        {
            "location": "/tutorial-8/#lean-app-tutorial-part-8", 
            "text": "This page assumes you've read Parts  1 ,  2 , 3 ,  4 ,  5 , 6 , and  7 .  Try the web app live now.  The end of  Part 7  promised a tutorial on inserting special\nsymbols into the document, which Lean understands.", 
            "title": "Lean App Tutorial, Part 8"
        }, 
        {
            "location": "/tutorial-8/#symbols", 
            "text": "Lean code can contain many Unicode characters that resemble mathematical\nnotation, and thus make documents more attractive.  This appliction supports\nthose characters, as shown in the image below.   The blackboard bold N stands for the natural numbers (formerly written nat)\nand the greek letter lambda stands for \"fun\" or \"assume\" in Lean.  You can enter these symbols by typing a backslash, followed by the symbol's\nname, followed by the spacebar (or alternately followed by another\nbackslash, if you're starting another symbol immediately afterwards).  For\nexample, to type the first line of the document shown above, you would\nproceed as follows.   Click the button to start a term group.  Type  check (3:\\nat .  Press the spacebar, and  \\nat  will be replaced by the blackboard bold\n    N.  Type  ) .", 
            "title": "Symbols"
        }, 
        {
            "location": "/tutorial-8/#catalog", 
            "text": "What symbols are available?  Lots!  Nearly 2,000, in fact!  But most of them\nare not useful in Lean itself.  Here are three ways to get started with\nkeyboard shortcuts:   The most important ones to know are  \\and ,  \\or ,  \\to ,  \\neg ,\n     \\forall ,  \\exists ,  \\pi ,  \\sigma ,  \\lambda ,  \\int , and  \\nat .  Take  the Lean tutorial , which\n    covers the keyboard shortcuts that work in Lean.  I imported the same\n    data file into this web app that they use in Lean, so all shortcuts that\n    work in Lean work here.  If you really want to know the full list of 1,959 shortcuts, you can\n    inspect  the (minified JSON) data file  just mentioned.", 
            "title": "Catalog"
        }, 
        {
            "location": "/tutorial-8/#so-what", 
            "text": "", 
            "title": "So what?"
        }, 
        {
            "location": "/tutorial-8/#benefits", 
            "text": "Your Lean documents will now look much less computer-ish, and much more\nmathematical and readable.", 
            "title": "Benefits"
        }, 
        {
            "location": "/tutorial-8/#missing-pieces", 
            "text": "This is the last page of the tutorial, but surely you can think of ways that\nthis app could be improved.  Feel free to  clone the project and start\ndeveloping with us!   Or contact one of the members\nof the development team through GitHub .\nYou can also open an issue there for bug reports or feature requests.", 
            "title": "Missing pieces"
        }
    ]
}