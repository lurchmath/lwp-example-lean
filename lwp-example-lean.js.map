{"version":3,"sources":["lwp-example-lean.litcoffee"],"names":["LeanOutputArray","LeanOutputObject","Module","bodyGroupToCode","bodyIsASection","checkTimer","clearAllValidity","clearValidity","documentToCode","hasValidity","isSubterm","leanCommands","markValid","myTimer","now","pathExists","runLeanOn","sectionGroupToCode","setValidity","startTimer","termGroupToCode","validate","validateButton","validationRunning","hasProp","hasOwnProperty","setAppName","addHelpMenuSourceCodeLink","window","helpAboutText","pluginsToLoad","push","Date","getTime","TOTAL_MEMORY","noExitRuntime","print","text","match","exec","type","file","line","char","info","test","Error","preRun","code","lean_init","lean_import_module","FS","writeFile","encoding","lean_process_file","group","symbol","hoverText","set","validOrNot","message","color","clear","get","groups","i","id","len","ref","tinymce","activeEditor","Groups","ids","length","citation","codeline","connection","detail","index","isError","j","k","l","lastError","leanCode","len1","len2","len3","len4","lineToGroupId","m","n","ref1","ref2","ref3","ref4","ref5","ref6","typeName","parent","lines","parseInt","join","replace","String","fromCharCode","results1","o","len5","connectionsOut","errors","groupToolbarButtons","tooltip","onclick","disabled","setTimeout","onPostRender","this","check","eval","import","open","constant","variable","definition","theorem","example","groupTypes","name","imageHTML","openImageHTML","closeImageHTML","contentsChanged","tagContents","command","contextMenuItems","newval","prompt","Object","keys","alert","connectionRequest","from","to","c","indexOf","call","undoManager","transact","disconnect","connect","connections","ins","outs","t","connectionsIn","slice","concat","arg","argMeanings","args","assignedBodies","assignedTypes","commandsTakingBodies","e","parentTerms","result","source","term","children","contentAsText","trim","error","lineOrLines","topLevel","split","destination","nextId","toExplore","visited","shift","useGroupConnectionsUI","rename","child","results","traverseForBodies","g","identifier","suffix","afterEditorReady","editor","on","event","allAfter","allBefore","allText","lastCharacter","modifiers","movements","newCursorPos","range","replaceWith","startFrom","toReplace","keyCode","selection","getRng","startContainer","endContainer","nodeType","textContent","startOffset","substr","substring","lastIndexOf","corrections","setStart","setEnd","setRng"],"mappings":"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","file":"lwp-example-lean.js","sourcesContent":["\n# Lean Example Application, Lurch Web Platform\n\n## Overview\n\nThis application can serve as an example of how to build an application on\nthe [Lurch Web Platform (LWP)](https://github.com/lurchmath/lurch).  But it\nis by far the most complex example application of its type.  In fact, it's a\nbit of a test case for how much you can do with the LWP.\n\nThis application does all of the following.\n * Imports the entire [Lean Prover](http://leanprover.github.io/)\n * Declares ways the user can write Lean semantics in a web-based word\n   processor\n * Creates rules that govern those structures and how to convert them into\n   code the Lean Prover can understand\n * Provides a command for running the Lean engine on that code\n * Converts all positive/negative feedback from the Lean engine back into\n   the appropriate locations in the word processor for user consumption\n\nConsequently, readers should not start learning the LWP through this\napplication.  See the several other example repositories of the form\n`lwp-example-<name>` within\n[the Lurch Project](https://github.com/lurchmath) on GitHub.\n\n    setAppName 'LeanApp'\n    addHelpMenuSourceCodeLink \\\n        'lwp-example-lean/blob/master/lwp-example-lean.litcoffee'\n    window.helpAboutText =\n        '<p>See the fully documented <a target=\"top\"\n        href=\"https://github.com/lurchmath/lwp-example-lean/blob/master/lwp-example-lean.litcoffee\"\n        >source code for this demo app</a>.</p>'\n\n[See a live version of this application online here.](https://lurchmath.github.io/lwp-example-lean/)\n\nThis application needs the equation editor plugin, so we must tell the setup\nscript to load it, by modifying the following global variable.\n\n    window.pluginsToLoad.push 'equationeditor'\n\n## Utilities for timing things\n\nJust a few simple definitions used throughout the file below.\n\n    myTimer = null\n    now = -> ( new Date ).getTime()\n    startTimer = -> myTimer = now()\n    checkTimer = -> \"(took #{now() - myTimer} ms)\"\n\n## Lean VM Setup\n\nHere we begin loading the Lean virtual machine.  This takes some time.  We\ndo it silently, but we leave several commented-out `console.log` statements\nbelow, so that you can see where certain events take place, and can monitor\nthose events on the console if you like, by uncommenting those lines.\n\nThe global variable `LeanOutputObject` is the current (if still under\nconstruction) or most recent (if just completed) object dumped by the Lean\nVM on its standard output channel.  The global variable `LeanOutputArray` is\nthe ordered collection of all such output objects, in the order they were\nproduced.\n\nNote that all this code must be run before the `lean.js` file from the\nlean.js repository is loaded.  This sets up the `Module` variable in the\nglobal namespace, so that the `lean.js` script can use the data we've placed\nthere to interface with our code.  In [index.html](the HTML page), at the\nend, you can see that we import this code first, then `lean.js`.\n\n    # console.log( '--- Loading Lean VM...' );\n    Module = window.Module = { }\n    Module.TOTAL_MEMORY = 64 * 1024 * 1024\n    Module.noExitRuntime = true\n    LeanOutputObject = null\n    LeanOutputArray = null\n    Module.print = ( text ) ->\n        match = null\n        if match = /FLYCHECK_BEGIN (.*)/.exec text\n            LeanOutputObject = type : match[1], text : [ ]\n        else if not LeanOutputObject\n            throw new Error 'Unexpected output from Lean: ' + text\n        else if match = /([^:]+):(\\d+):(\\d+): (.*)/.exec text\n            LeanOutputObject.file = match[1]\n            LeanOutputObject.line = match[2]\n            LeanOutputObject.char = match[3]\n            LeanOutputObject.info = match[4]\n        else if /FLYCHECK_END/.test text\n            # console.log 'Lean output: ' \\\n            #           + JSON.stringify LeanOutputObject, null, 4\n            LeanOutputArray.push LeanOutputObject\n            LeanOutputObject = null\n        else\n            LeanOutputObject.text.push text\n    Module.preRun = [\n        ->\n            # console.log '--- Lean VM loaded.', checkTimer()\n            # console.log '--- Running Lean VM...'\n            # startTimer()\n    ]\n    # Module.postRun = ->\n    #     console.log '--- Lean VM has been run.', checkTimer()\n\n## Lean Engine\n\nThe following function runs the Lean engine on a string input, treating that\nstring as an entire input file (with line and column numbers, as if Lean\nwere being run from the command line, not the web).  All feedback and/or\nerror messages produced by the engine are converted into output objects by\nthe `Module.print` function, above, and collected into the global variable\n`LeanOutputArray`, which this function then returns.\n\nAgain, users who wish to see a lot of debugging and timing output can\nuncomment the debugging and timing lines below.  We leave them in because\nthey double as simple comments about what the code does.\n\n    runLeanOn = window.runLeanOn = ( code ) ->\n        # console.log '--- Calling lean_init()...'\n        # startTimer()\n        Module.lean_init false\n        # console.log '--- lean_init() complete.', checkTimer()\n        # console.log '--- Importing Lean standard module...'\n        # startTimer();\n        Module.lean_import_module \"standard\"\n        # console.log '--- Standard module imported.', checkTimer()\n        # console.log '--- Writing test.lean to virtual filesystem...'\n        # startTimer()\n        # console.log code\n        FS.writeFile 'test.lean', code, encoding : 'utf8'\n        # console.log '--- test.lean written.', checkTimer()\n        # console.log '--- Running Lean on test.lean...'\n        # startTimer()\n        LeanOutputArray = [ ]\n        Module.lean_process_file 'test.lean'\n        # console.log '--- Lean has been run on test.lean.', checkTimer()\n        LeanOutputArray\n\n## Validation\n\nTo track whether validation is running, we use a global boolean.\n\n    validationRunning = no\n\nWe also create a few functions for marking a group valid or invalid, for\nclearing or checking whether a group has validation information, and for\nclearing all validation information so that a new run of validation can then\noperate on a clean slate.\n\n    setValidity = ( group, symbol, hoverText ) ->\n        group.set 'closeDecoration', symbol\n        group.set 'closeHoverText', hoverText\n    markValid = ( group, validOrNot, message ) ->\n        color = if validOrNot then 'green' else 'red'\n        symbol = if validOrNot then '&#10003;' else '&#10006;'\n        setValidity group, \"<font color='#{color}'>#{symbol}</font>\",\n            message\n    clearValidity = ( group ) ->\n        group.clear 'closeDecoration'\n        group.clear 'closeHoverText'\n    hasValidity = ( group ) ->\n        'undefined' isnt typeof group.get 'closeDecoration'\n    clearAllValidity = ->\n        if validationRunning then return\n        validationRunning = yes\n        groups = tinymce.activeEditor.Groups\n        clearValidity groups[id] for id in groups.ids()\n        validationRunning = no\n\nNow, the validation routine that operates on the whole document at once.  It\npresumes that you have just run `clearAllValidity()`.  Much of the code in\nthis routine will not make sense to the reader who has not read the tutorial\non how to use this app; start there first.\n\n    validate = window.validate = ->\n        groups = tinymce.activeEditor.Groups\n\nIf validation is running, then this call is probably the result of\nrecursion.  That is, changes to the document that happen during validation\nare attempting to re-start validation in response to those changes.  They\nshould be ignored.\n\n        if validationRunning then return\n        validationRunning = yes\n\nFor any term group whose parent is also a term group, mark it invalid for\nthat reason.\n\n        for id in groups.ids()\n            if groups[id].typeName() is 'term' and \\\n               groups[id].parent?.typeName() is 'term'\n                markValid groups[id], no,\n                    'A term group cannot be inside another term group.'\n\nCompute the Lean code for the entire document.  (This routine is defined\nlater in this file.)  We then create a mapping from lines in that file to\ngroup IDs that generated those lines, so that we can trace errors back to\ntheir origins.\n\n        lineToGroupId = { }\n        for line, index in ( leanCode = documentToCode() ).lines\n            if m = /[ ]--[ ](\\d+)$/.exec line\n                lineToGroupId[index + 1] = parseInt m[1]\n\nRun Lean on that input and process all output.\n\n        lastError = -1\n        code = leanCode.lines.join( '\\n' ).replace \\\n            String.fromCharCode( 160 ), String.fromCharCode( 32 )\n        for message in runLeanOn code\n            id = lineToGroupId[message.line]\n            if isError = /error:/.test message.info then lastError = id\n            detail = \"Lean reported:\\n\\n#{message.info}\"\n            if message.text.length\n                detail += '\\n' + message.text.join '\\n'\n            citation = parseInt message.char\n            citation = if citation > 0\n                codeline = leanCode.lines[message.line - 1]\n                \"\\n\\ncharacter ##{citation + 1} in this code:\n                 \\n#{/^(.*) -- \\d+$/.exec( codeline )[1]}\"\n            else\n                ''\n            markValid groups[id], not isError, detail + citation\n        for id in groups.ids()\n            if id is lastError then break\n            if not hasValidity groups[id]\n                markValid groups[id], yes, 'No errors reported.'\n\nAny type groups without arrows to term groups must be marked with a message\nto tell the user that they were not part of validation (and perhaps indicate\na mistake on the user's part in input).  The only exceptions are body groups\nacting as subterms.\n\n        for id in groups.ids()\n            if ( typeName = groups[id].typeName() ) is 'type'\n                if isSubterm groups[id] then continue\n                modifiedTerms = ( connection[1] \\\n                    for connection in groups[id].connectionsOut() \\\n                    when groups[connection[1]].typeName() is 'term' )\n                if modifiedTerms.length is 0\n                    setValidity groups[id],\n                        '<font color=\"#aaaa00\"><b>&#10039;</b></font>',\n                        \"This #{typeName} does not modify any terms, and was\n                        thus ignored in validation.  Did you mean to connect\n                        it to a term?\"\n\nAlso mark invalid any group that couldn't be converted to Lean code in the\nfirst place.\n\n        for own id, message of leanCode.errors\n            markValid groups[id], no, message\n\nValidation is complete.\n\n        validationRunning = no\n\nAdd a validate button to the toolbar.  It disables itself and shows\nalternate text while Lean is running, because that process is time-consuming\nand therefore needs some visual cue for the user about its progress.  We use\nthe zero timeout below to ensure that the UI is updated with the\n\"Running...\" message before it locks up during the Lean run.\n\n    validateButton = null\n    window.groupToolbarButtons.validate =\n        text : 'Run Lean'\n        tooltip : 'Run Lean on this document'\n        onclick : ->\n            validateButton.text 'Running...'\n            validateButton.disabled yes\n            setTimeout ->\n                validate()\n                validateButton.disabled no\n                validateButton.text 'Run Lean'\n            , 0\n        onPostRender : -> validateButton = this\n\n## Lean Commands\n\nThe following Lean commands are permissible on terms.  Each comes with a\nformat for how it is converted into a line of Lean code.\n\n    leanCommands =\n        check : 'check (TERM)'\n        eval : 'eval (TERM)'\n        print : 'print \"TERM\"'\n        import : 'import TERM'\n        open : 'open TERM'\n        constant : 'constant TERM'\n        variable : 'variable TERM'\n        definition : 'definition TERM'\n        theorem : 'theorem TERM'\n        example : 'example TERM'\n\n## Term Groups\n\nDeclare a new type of group in the document, for Lean terms.  We do not\ndocument each of these properties here, because they were documented more\nthoroughly in the simpler Lurch Web Platform example apps linked to at the\ntop of this file.\n\n    window.groupTypes = [\n        name : 'term'\n        text : 'Lean Term'\n        tooltip : 'Make the selection a Lean term'\n        color : '#666666'\n        imageHTML : '<font color=\"#666666\"><b>[ ]</b></font>'\n        openImageHTML : '<font color=\"#666666\"><b>[</b></font>'\n        closeImageHTML : '<font color=\"#666666\"><b>]</b></font>'\n        contentsChanged : clearAllValidity\n\nIts tag will advertise any Lean command embedded in the group.\n\n        tagContents : ( group ) ->\n            if command = group.get 'leanCommand'\n                \"Command: #{command}\"\n            else\n                null\n\nIts context menu permits adding, editing, or removing a Lean command\nembedded in the group.\n\n        contextMenuItems : ( group ) -> [\n            text : 'Edit command...'\n            onclick : ->\n                newval = prompt 'Enter the Lean command to use on this code\n                    (or leave blank for none).\\n\n                    \\nValid options include:\\n' + \\\n                    Object.keys( leanCommands ).join( ' ' ),\n                    group.get( 'leanCommand' ) ? ''\n                if newval isnt null\n                    if newval is ''\n                        group.clear 'leanCommand'\n                    else if newval not of leanCommands\n                        alert 'That was not one of the choices.  No change\n                            has been made to your document.'\n                    else\n                        group.set 'leanCommand', newval\n        ]\n\nWe can connect term groups to other term groups, or to body groups.  We are\nnot permitted to make a cycle.\n\n        connectionRequest : ( from, to ) ->\n            if to.typeName() isnt 'term' and to.typeName() isnt 'body'\n                return\n            if to.id() in ( c[1] for c in from.connectionsOut() )\n                tinymce.activeEditor.undoManager.transact ->\n                    from.disconnect to\n            else if pathExists to.id(), from.id()\n                alert 'That would create a cycle of arrows, which is not\n                    permitted.'\n            else\n                tinymce.activeEditor.undoManager.transact -> from.connect to\n\nWhen drawing term groups, draw all arrows that come in or go out.  (The\ndefault is to only draw arrows that go out; we override that here, so that a\nterm's type is clearly highlighted when the term is highlighted.)\n\n        connections : ( group ) ->\n            outs = group.connectionsOut()\n            ins = group.connectionsIn()\n            [ outs..., ins...,\n              ( t[1] for t in outs )..., ( t[0] for t in ins )... ]\n        # tagMenuItems : ( group ) -> ...compute them here...\n    ]\n\nThe following function computes the meaning of a top-level Term Group in the\ndocument.\n\n    termGroupToCode = window.termGroupToCode = ( group ) ->\n        groups = tinymce.activeEditor.Groups\n\nIf the group contains any other group, have the result be the empty string,\nbecause that structure is invalid.\n\n        if group.children.length > 0\n            throw Error 'Invalid structure: Term groups may not contain\n                other groups'\n\nStart with the group's contents, as text.  This can be something as simple\nas `1` for a term for the number one, or as complex as an entire proof\nobject, written in Lean syntax (e.g., `(assume H : p, ...big proof...)`).\n\n        term = group.contentAsText().trim()\n\nIf this group has arrows to other groups, compute their meanings for use as\npart of this group's meaning.\n\n        args = ( connection[1] for connection in group.connectionsOut() )\n        argMeanings = for arg in args\n            try\n                if groups[arg].typeName() is 'term'\n                    termGroupToCode groups[arg]\n                else\n                    bodyGroupToCode groups[arg]\n            catch e\n                markValid groups[arg], no, e.message\n                throw Error \"A term to which this term points (directly or\n                    indirectly) contains an error, and thus this term's\n                    meaning cannot be determined.\"\n\nIf there were arguments, make this term an application of its head to those\narguments.\n\n        if args.length > 0\n            term = \"( -- #{group.id()}\\n\n            #{term} -- #{group.id()}\\n\n            #{argMeanings.join '\\n'}\\n\n            )\"\n\nFind any incoming arrows to this term that may matter below.\n\n        parentTerms = [ ]\n        assignedTypes = [ ]\n        assignedBodies = [ ]\n        for connection in group.connectionsIn()\n            source = groups[connection[0]]\n            if source.typeName() is 'type'\n                type = source.contentAsText().trim()\n                if type not in assignedTypes then assignedTypes.push type\n            else if source.typeName() is 'body' and \\\n               source.id() not in assignedBodies\n                assignedBodies.push source.id()\n            else if source.typeName() is 'term'\n                parentTerms.push source\n\nIf there is more than one type group modifying this group, or more than one\nbody group modifying this group, throw an error.  If this is a subterm of\nanother term, permit no type or body assignments.\n\n        if assignedTypes.length > 1\n            throw Error \"Invalid structure: Two different types are assigned\n                to this term (#{assignedTypes.join ', '})\"\n        if assignedBodies.length > 1\n            throw Error \"Invalid structure:\n                Two bodies are assigned to this term.\"\n        if parentTerms.length > 0\n            if assignedTypes.length > 0\n                throw Error \"Invalid structure: A subterm of another term\n                    cannot have a type assigned.\"\n            if assignedBodies.length > 0\n                throw Error \"Invalid structure: A subterm of another term\n                    cannot have a body assigned.\"\n\nIf we've found a unique type, insert it after the first identifier, or after\nthe end of the whole term.  For example, if the term were `a := b` we would\ncreate `a : type := b`, but if it were `(and.intro H1 H2)` then we would\ncreate `(and.intro H1 H2) : type`.\n\n        if assignedTypes.length > 0\n            type = assignedTypes[0]\n            if match = /^\\s*check\\s+(.*)$/.exec term\n                term = \"check (#{match[1]} : #{type})\"\n            else if match = /^\\s*check\\s+\\((.*)\\)\\s*$/.exec term\n                term = \"check (#{match[1]} : #{type})\"\n            else if match = /^(.*):=(.*)$/.exec term\n                term = \"#{match[1]} : #{type} := #{match[2]}\"\n            else\n                term = \"#{term} : #{type}\"\n\nPrepend any Lean command embedded in the group.\n\n        if command = group.get 'leanCommand'\n            term = leanCommands[command].replace 'TERM', term\n\nAppend a one-line comment character, followed by the group's ID, to track\nwhere this line of code came from in the document, for the purposes of\ntransferring Lean output back to this group as user feedback.\n\n        result = \"#{term} -- #{group.id()}\"\n\nIf we've found a unique body, insert it after the term, with a `:=` in\nbetween.\n\n        if assignedBodies.length > 0\n            commandsTakingBodies = [ 'theorem', 'definition', 'example' ]\n            if command not in commandsTakingBodies\n                throw Error \"Terms may only be assigned bodies if they embed\n                    one of these commands:\n                    #{commandsTakingBodies.join ', '}.\"\n            result += \"\\n:= #{bodyGroupToCode groups[assignedBodies[0]]}\"\n\nDone computing the code for this term group.\n\n        result\n\nThe following function converts the document into Lean code by calling\n`termGroupToCode` on all top-level term groups in the document.  If this\narray were joined with newlines between, it would be suitable for passing\nto Lean.  It ignores non-term groups, and it ignores term groups that are\nsubterms of other terms.  The only exception to this is body terms not\nattached to a term, which therefore function as sections.\n\n    documentToCode = window.documentToCode = ->\n        result = lines : [ ], errors : { }\n        for group in tinymce.activeEditor.Groups.topLevel\n\nIf it's a section, handle that with `sectionGroupToCode`.\n\n            if group.typeName() is 'body' and bodyIsASection group\n                lineOrLines = sectionGroupToCode group\n                result.lines = result.lines.concat lineOrLines.split '\\n'\n                continue\n\nThen filter out non-terms and subterms.\n\n            if group.typeName() isnt 'term' or isSubterm group\n                continue\n\nHere we call the appropriate code-generating function, and handle any errors\nit generates.\n\n            try\n                lineOrLines = termGroupToCode group\n                result.lines = result.lines.concat lineOrLines.split '\\n'\n            catch e\n                result.errors[group.id()] = e.message\n        result\n\nHere is the `isSubterm` function used below.  It determines whether a term\ngroup is a subterm of another term group.\n\n    isSubterm = ( term ) ->\n        for connection in term.connectionsIn()\n            if tinymce.activeEditor.Groups[connection[0]].typeName() \\\n                is 'term' then return yes\n        no\n\nThe following function determines if a body is attached to no term, and thus\nfunctions as a section.\n\n    bodyIsASection = ( group ) ->\n        for connection in group.connectionsOut()\n            if tinymce.activeEditor.Groups[connection[1]].typeName() \\\n                is 'term' then return no\n        yes\n\nThe following function checks to see if you can get from one group to\nanother in the document by following connections forwards.  This is useful\nin the code above for preventing cyclic connections.\n\nIt tracks which nodes we've visited (starting with none) and which nodes we\nmust explore from (starting with just the source).  At each step, it visits\nthe next unexplored node, marks it visited, and if it's the first stop\nthere, adds all its reachable neighbors to the nodes we must explore from.\nIf at any point we see the destination, say so.  If we finish exploring all\nreachable nodes without seeing it, say so.\n\n    pathExists = ( source, destination ) ->\n        groups = tinymce.activeEditor.Groups\n        visited = [ ]\n        toExplore = [ source ]\n        while toExplore.length > 0\n            if ( nextId = toExplore.shift() ) is destination then return yes\n            if nextId in visited then continue else visited.push nextId\n            toExplore = toExplore.concat \\\n                ( c[1] for c in groups[nextId].connectionsOut() )\n        no\n\n## Type Groups\n\nDeclare a new type of group in the document, for Lean types.  We do not\ndocument each of these properties here, because they were documented more\nthoroughly in the simpler Lurch Web Platform example apps linked to at the\ntop of this file.\n\n    window.groupTypes.push\n        name : 'type'\n        text : 'Lean Type'\n        tooltip : 'Make the selection a Lean type'\n        color : '#66bb66'\n        imageHTML : '<font color=\"#66bb66\"><b>[ ]</b></font>'\n        openImageHTML : '<font color=\"#66bb66\"><b>[</b></font>'\n        closeImageHTML : '<font color=\"#66bb66\"><b>]</b></font>'\n        contentsChanged : clearAllValidity\n\nWe can connect type groups to term groups only.  We are not permitted to\nmake a cycle.\n\n        connectionRequest : ( from, to ) ->\n            if to.typeName() isnt 'term' then return\n            if to.id() in ( c[1] for c in from.connectionsOut() )\n                tinymce.activeEditor.undoManager.transact ->\n                    from.disconnect to\n            else\n                tinymce.activeEditor.undoManager.transact -> from.connect to\n\nInstall the arrows UI so that types can connect to terms.\n\n    window.useGroupConnectionsUI = yes\n\n## Body Groups\n\nDeclare a new type of group in the document, for the bodies of definitions,\ntheorems, examples, sections, and namespaces.  We do not document each of\nthese properties here, because they were documented more thoroughly in the\nsimpler Lurch Web Platform example apps linked to at the top of this file.\n\n    window.groupTypes.push\n        name : 'body'\n        text : 'Body of a Lean definition or section'\n        tooltip : 'Make the selection a body'\n        color : '#6666bb'\n        imageHTML : '<font color=\"#6666bb\"><b>[ ]</b></font>'\n        openImageHTML : '<font color=\"#6666bb\"><b>[</b></font>'\n        closeImageHTML : '<font color=\"#6666bb\"><b>]</b></font>'\n        contentsChanged : clearAllValidity\n\nIts context menu permits converting an unconnected body group between being\na namespace and being a section.\n\n        contextMenuItems : ( group ) ->\n            rename = ->\n                newval = prompt 'Enter the identifier to use as the name of\n                    the namespace.', group.get 'namespace'\n                if newval isnt null\n                    if not /^[a-zA-Z_][a-zA-Z0-9_]*$/.test newval\n                        alert 'That was a valid Lean identifier.  No change\n                            has been made to your document.'\n                    else\n                        group.set 'namespace', newval\n            if not bodyIsASection group\n                [ ]\n            else if name = group.get 'namespace'\n                [\n                    text : 'Make this a section'\n                    onclick : -> group.clear 'namespace'\n                ,\n                    text : 'Rename this namespace...'\n                    onclick : rename\n                ]\n            else\n                [\n                    text : 'Make this a namespace...'\n                    onclick : rename\n                ]\n\nIf this body is unconnected to a term, then it functions as a section.\n\n        tagContents : ( group ) ->\n            if bodyIsASection group\n                if name = group.get 'namespace'\n                    \"Namespace: #{name}\"\n                else\n                    'Section'\n            else\n                ''\n\nWe can connect body groups to term groups only.  We are not permitted to\nmake a cycle.\n\n        connectionRequest : ( from, to ) ->\n            if to.typeName() isnt 'term' then return\n            if to.id() in ( c[1] for c in from.connectionsOut() )\n                tinymce.activeEditor.undoManager.transact ->\n                    from.disconnect to\n            else if pathExists to.id(), from.id()\n                alert 'That would create a cycle of arrows, which is not\n                    permitted.'\n            else\n                tinymce.activeEditor.undoManager.transact -> from.connect to\n\nThe following function computes the meaning of a top-level Body Group in the\ndocument.  It is like `termGroupToCode`, but for bodies instead.\n\n    bodyGroupToCode = window.bodyGroupToCode = ( group ) ->\n\nFind body/term-type children, and verify that at least one exists.  If not,\nthen we treat this as a special case, a body containing just one term,\nexpressed as Lean code.  (This is handy for very small bodies, such as a\nsingle identifier or number.)\n\n        children = ( child for child in group.children \\\n            when child.typeName() is 'term' or child.typeName() is 'body' )\n        if children.length is 0\n            return \"#{group.contentAsText()} -- #{group.id()}\"\n\nVerify that none but the last one is a body group (although the last one is\nalso permitted to be a term group).\n\n        for child, index in children[...-1]\n            if child.typeName() is 'body'\n                throw Error \"A body group can only contain other body groups\n                    as its final child.  This one has another body group\n                    as child ##{index + 1}.\"\n\nVerify that none of the children has a body group pointing to it, because\ndefinitions, sections, etc. cannot be nested.\n\n        groups = tinymce.activeEditor.Groups\n        traverseForBodies = ( g ) ->\n            for connection in g.connectionsIn()\n                if groups[connection[0]].typeName() is 'body'\n                    throw Error 'One of the groups inside this body has a\n                        body group connected to it.  That type of nesting is\n                        not permitted.'\n            traverseForBodies child for child in g.children\n        traverseForBodies group\n\nRecur on all children that are not subterms of something else.\n\n        results = [ ]\n        for child in children\n            if child.typeName() == 'term'\n                if isSubterm child then continue\n                results.push termGroupToCode child\n            else\n                results.push bodyGroupToCode child\n\nAdjust all but the last entry to be assumptions, and we're done.\n\n        for index in [0...results.length-1]\n            match = /^(.*) -- (\\d+)$/.exec results[index]\n            results[index] = \"assume #{match[1]}, -- #{match[2]}\"\n        results.join '\\n'\n\nAn empty body functions as a section.\n\n    sectionGroupToCode = window.sectionGroupToCode = ( group ) ->\n        name = group.get 'namespace'\n        type = if name then 'namespace' else 'section'\n        suffix = name ? group.id()\n        identifier = ( if type is 'namespace' then '' else type ) + suffix\n        results = [ ]\n        for child in group.children\n            if isSubterm child then continue\n            try\n                if child.typeName() is 'term'\n                    results.push termGroupToCode child\n                else if child.typeName() is 'body'\n                    if not bodyIsASection child then continue\n                    results.push sectionGroupToCode child\n            catch e\n                markValid child, no, e.message\n        \"#{type} #{identifier} -- #{group.id()}\\n\n        #{results.join '\\n'}\\n\n        end #{identifier} -- #{group.id()}\"\n\n## Substitutions\n\nNow we install code that watches for certain key text pieces that can be\nreplaced by Lean-related symbols.\n\n    window.afterEditorReady = ( editor ) ->\n        editor.on 'KeyUp', ( event ) ->\n            movements = [ 33..40 ] # arrows, pgup/pgdn/home/end\n            modifiers = [ 16, 17, 18, 91 ] # alt, shift, ctrl, meta\n            if event.keyCode in movements or event.keyCode in modifiers\n                return\n            range = editor.selection.getRng()\n            if range.startContainer is range.endContainer and \\\n               range.startContainer?.nodeType is 3 # HTML Text node\n                allText = range.startContainer.textContent\n                lastCharacter = allText[range.startOffset-1]\n                if lastCharacter isnt ' ' and lastCharacter isnt '\\\\' and \\\n                   lastCharacter isnt String.fromCharCode( 160 )\n                    return\n                allBefore = allText.substr 0, range.startOffset - 1\n                allAfter = allText.substring range.startOffset - 1\n                startFrom = allBefore.lastIndexOf '\\\\'\n                if startFrom is -1 then return\n                toReplace = allBefore.substr startFrom + 1\n                allBefore = allBefore.substr 0, startFrom\n                if not replaceWith = corrections[toReplace] then return\n                newCursorPos = range.startOffset - toReplace.length - 1 + \\\n                    replaceWith.length\n                if lastCharacter isnt '\\\\'\n                    allAfter = allAfter.substr 1\n                    newCursorPos--\n                range.startContainer.textContent =\n                    allBefore + replaceWith + allAfter\n                range.setStart range.startContainer, newCursorPos\n                range.setEnd range.startContainer, newCursorPos\n                editor.selection.setRng range\n"]}